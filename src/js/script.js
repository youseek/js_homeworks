"use strict";

//Приклад 1:

// console.log(a); // Виведе: undefined
// var a = 10; // Об'явлення перемінної 'a' та її ініціалізація
// У цьому випадку, хоча console.log(a) викликається перед ініціалізацією змінної a, код не видасть помилку через hoisting.
// Змінна a буде піднята вгору (hoisted), тобто інтерпретатор спочатку розгляне всі об'явлення змінних, а потім виконає код. Але значення змінної a на момент виклику console.log(a) ще не визначено, тому виведе undefined.

// Приклад 2:
//
// myFunction(); // Виведе: Hello, world!
// function myFunction() {
//     console.log('Hello, world!');
// }
// У цьому випадку, функція myFunction об'явлена перед її викликом, тому немає проблем з hoisting.

// Приклад 3:
//
// console.log(b); // Видасть помилку: ReferenceError: Cannot access 'b' before initialization
// let b = 5; // Об'явлення змінної 'b' та її ініціалізація
// У цьому випадку виникає помилка через те, що змінна b об'явлена за допомогою let, і хоча її об'явлення піднімається вгору, ініціалізація (присвоєння значення) не піднімається разом з нею. Тому спроба вивести b перед ініціалізацією видасть помилку.

// Приклад 4:
// const myArrowFunction = () => {
//     console.log('Hello from arrow function');
// }
// myArrowFunction(); // Виведе: Hello from arrow function
// У цьому випадку немає проблем з hoisting, оскільки стрілкові функції не можуть бути об'явлені зазвичай, а тому не піднімаються вгору. Функцію присвоєно до змінної myArrowFunction, і ця змінна піднімається вгору, тому виклик myArrowFunction() буде успішним.

// Напишіть власні приклади коду, де:

// В одному випадку hoisting призводить до успішного виконання коду.

myFunction(); // Виведе: Hello, world!
function myFunction() {
  console.log("Hello, world!");
}

// В іншому випадку hoisting призводить до помилки. Поясніть, чому сталася помилка.

console.log(b); // Видасть помилку: ReferenceError: Cannot access 'b' before initialization
let b = 5; // Об'явлення змінної 'b' та її ініціалізація
// У цьому випадку виникає помилка через те, що змінна b об'явлена за допомогою let, і хоча її об'явлення піднімається вгору, ініціалізація (присвоєння значення) не піднімається разом з нею. Тому спроба вивести b перед ініціалізацією видасть помилку.
